\documentclass{article}

\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{amssymb}
%\usepackage{biblatex}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]


\title{Version Space Algebras and Category Theory}
\author{Bailey Wickham}

\begin{document}
\maketitle

\begin{abstract}
Version space algebras are objects primarily used in machine learning to model a domain and then restrictions of that domain to a set of predictions. They are constructed using basic set theory, but many of their definitions translate naturally into category theory. We give a category theoretic definition of version space algebras and their operations. 
\end{abstract}

\section{Introduction}
Version spaces were first developed as a framework for machine learning in the 1980s \cite{original}. Initially they were used to generate predictions based on a small set of examples. They served as a precursor to modern machine learning methods. In recent years machine learning has mostly taken a different approach, yet there is still some recent work on version spaces. 

Similar to current tensor-based methods, version spaces provide a space of all possible functions (a domain) and examples which constrain those functions to usable predictions. The set of all possible functions is called the \textit{hypothesis space}, and a single function is called a \textit{hypothesis}. These are used to generate predictions, with each providing a hypothesis of what the user is asking. The functions available are constrained by the examples, which narrow the hypothesis space down to the best predictions of what the user wants.

The primary example defined in \cite{short} is a text editor called SMARTEdit. In this example, a user may want to perform complex actions such as \texttt{delete text between these quotes}, or \texttt{move down five lines then copy the text until the word ``Hello"}. The version space algebra for this example is built by a small set of base version spaces called \textit{atomic version spaces}, and algebraic operations on them such as union and intersection. For the specific version space that corresponds to moving between rows, the hypothesis space might be the space of all functions which map an integer to another integer. After the user records an action such as ``jump from the second row to the fifth", or $f(2) = 5$, the version space collapses to only those functions for which $f(2) = 5$. The complete version space algebra which corresponds to SMARTEdit is built by combining these atomic version spaces.

Due to their development in applied machine learning, all of the constructions are based entirely in set theory. However these constructs can be translated into a category. In this paper, we will first outline the original definitions for version spaces, then translate them into a category theoretic context. 

\section{Version Spaces}
There are four main components in defining a version space: 
\begin{itemize}
    \item $H$: The \textit{hypothesis space}
    \item $D$: The \textit{examples}
    \item $VS_{H,D}$: the \textit{version space}
    \item The algebraic operations on version spaces
\end{itemize}

%Lau et al.\cite{short}  define a Version Space $VS_{H,D}$ as such: 

\subsection{The hypothesis space}

The \textbf{hypothesis space} is a set of functions with a common domain $A$ and codomain $B$, labeled $H = \{f | f: A \rightarrow B \}$. Each function $h \in H$ is called a \textbf{hypothesis}.  The hypotheses space provides a ``domain" to work in, or a set of all hypothesises of functions which could be used to generate predictions. As we train our version space, the set of hypotheses shrinks to match our updated data. 

For example, $H = \{f: f: \mathbb{Z} \rightarrow \mathbb{Z}\}$, the set of functions which send an integer to an integer. An element of this space, $f\in H$ could be $f(x) = x + 3$ or $f(x) = 3$, the only requirement for $f$ is that it is a function. For a more applicable example, let $A = \{hi, hello, world\}$ and $H = \{f: f: A\rightarrow \mathbb{Z}\}$. Let $f\in H$ be the length of the word in $A$. 

\subsection{The examples}
Given a domain $A$ and a codomain $B$, an \textbf{example} is a pair $(i, o)\in A \times B$. The \textbf{examples} are a set of examples $D$ i.e. $D \subseteq A \times B$. For instance, $(1,2) \in \mathbb{Z} \times \mathbb{Z}$, or using the previous set, $A = \{hi, hello, world\}$, an example: $(hi, 2) \in A \times \mathbb{Z}$

A hypothesis $f: A\rightarrow B$ is \textbf{consistent} with an example $(i,o) \in A\times B$ if $f(i) = o$. Using our two examples above, $f\in H $ is consistent with $(1,2)$ if $f(1) = 2$. 

The hypothesis space provides a domain to work in, or a space of functions which could possibly be models for our predictions. The examples serve to constrain which functions we are studying, giving a way to refine the ambient space into a specific model.  The examples, $D$, are pairs of elements in the domain and range of these functions which our model should respect. 


\subsection{Version space algebras}
Let $H$ be a hypothesis space with domain $A$ and codomain $B$ and examples $D \subseteq A \times B$. A \textbf{version space} $VS_{H,D} = \{f : f(i) = o \text{ for all } (i,o) \in D\}$, or the hypotheses in $H$ that are consistent with all examples in $D$. 

A version space is the set of the functions in the ambient space that are consistent with the examples. In practice the ambient space may be something like "words in our document", or "integers representing row and column numbers".  Version spaces are used to define all possible actions of a specific type, then constrained to the examples observed in the current document. This is used to generate predictions, where the examples we have used in our document are used to predict future actions.
Following our above working example, $VS_{H,D} = \{f : f: \mathbb{Z} \rightarrow \mathbb{Z} \text{ and } f(1) = 2\}$

Lau et al.\cite{short} introduces the idea of version space algebras (VSAs), that are version spaces generated by algebraic operations on other version spaces. A version space which is defined explicitly, or not defined in terms of operations on other version spaces, is called an \textbf{atomic version space}. From a set theory perspective there is no difference between a version space algebra and a version space, there is only a difference in how they are constructed. 

\subsection{Algebraic operations on version spaces}
There are three main operations defined on a version space. 
\begin{definition}
    Let $H_1 \subseteq \{f | f: A \rightarrow B\}$ and $H_2 \subseteq \{f | f: A \rightarrow B\}$ be hypothesis spaces with the same domain and codomain. Let $D$ be a set of examples. Then the \textbf{version space union} of $VS_{H_1, D}$ and $VS_{H_2, D}$ is $VS_{H_1, D} \bigcup VS_{H_2, D} = VS_{H_1\bigcup H_2, D}$. The \textbf{version space intersection} of $VS_{H_1, D}$ and $VS_{H_2, D}$ is $VS_{H_1, D} \bigcap VS_{H_2, D} = VS_{H_1\bigcap H_2, D}$.
\end{definition}

\begin{definition}
Let $A_1, A_2, B_1 $ and $B_2$ be sets, $H_1 \subseteq \{g : g: A_1 \rightarrow B_1\}$ and $H_2 \subseteq \{f: f: A_2 \rightarrow B_2\}$. Let $\tau_i: A_1 \rightarrow A_2$ be a function between the domains and $\tau_o:B_1 \rightarrow B_2$ be an invertible function between the codomains. Version space $VS_{H_1, D_1}$ is a \textbf{transform} of $VS_{H_2, D_2}$ if $VS_1 = \{g : \exists f \in VS_2, \forall i,  g(i) = \tau_o^{-1}(f(\tau_i(i)))\}$

While not provided in \cite{short}, a transform can be represented the set of all $g:A_1 \rightarrow B_1$ for which there exists $f \in VS_2$ such that the diagram below commutes.

\[\begin{tikzcd}
	{A_1} & {B_1} \\
	{A_2} & {B_2}
	\arrow["{\tau_i}", from=1-1, to=2-1]
	\arrow["g"', from=1-1, to=1-2]
	\arrow["{\tau_o}", to=2-2, from=1-2]
	\arrow["f", from=2-1, to=2-2]
\end{tikzcd}\]

The original definition of a version space transform is part of what originally motivated the study of category theory. The definition can be represented as a commutative diagram which simplifies presentation. We were interested in studying what other aspects of version spaces can be simplified using category theory.

\subsection{Training}
When \textit{training} a version space, we start with a hypothesis space $H$ and no examples. Training consists of adding pairs to $D$, which causes $VS_{H,D}$ to shrink. This gives us a contravariant chain of inclusion maps which represent training the version space,
\[\begin{tikzcd}
	{VS_{H,D_{n-1}}} & {VS_{H,D_n}} & {VS_{H,D_{n+1}}} \\
	{D_{n-1}} & {D_n} & {D_{n+1}}
	\arrow[hook, from=1-3, to=1-2]
	\arrow[hook, from=2-2, to=2-3]
	\arrow[hook, from=1-2, to=1-1]
	\arrow[hook, from=2-1, to=2-2]
\end{tikzcd}\]

\end{definition}

\section{Category Theory}
We next redefine version spaces in a categorical framework. To start, we make a simplification to the definition of examples. In Section 2, we defined the examples as pairs $(i, o) \in A\times B$ where $A$ is the domain and $B$ is the codomain of the hypothesis space. If there exists a two pairs $(i, o_1)$ and $(i, o_2)$ where $o_1\neq o_2$, then the version space is the empty set as no function $f$ can satisfy those conditions. If we disallow conflicting examples such as this one, then a set of examples can be represented as a function $g_D : A' \rightarrow B$ where $A' \subseteq A$. Then our definition of version space can be restated as $VS_{H,g_D} = \{f \in H : f|_{A'} = g_D\}$ In this section we will use this simplified definition of examples.

%\begin{definition}[Version Space (Category)]
%Let $A$ and $B$ be small sets. Then a hypothesis space $H \hookrightarrow Hom_{Set}(A, B)$. Let the examples, $D$, be a set of pairs $\{(a,b) : a \in A, b \in B\}$ $(a,b)$ that project via maps $\partial_0, \partial_1$ into $A$ and $B$ respectively.
%
%Let $\Gamma_f$ be the graph functor: $\Gamma_f = \{(a,b) | b = f(a)\} \subseteq A\times B$. We can define a version space as the set  $VS_{H,D} = \{f : D \rightarrow \Gamma_f \text{ is injective}\}$. We say $D$ is consistent with $f$ if $D \rightarrow \Gamma_f$ is injective. A version space is all of the functions which are consistent with all of the examples: $VS_{H, D} = \{f : \text{ D is consistent with } \Gamma_f $ \}
%
%Define the projection $\pi_D : VS_{H,D} \rightarrow D$, and $\Gamma_H = \{\Gamma_f : f \in H\}$
%We can phrase this as a diagram: 
%% https://q.uiver.app/?q=WzAsMyxbMCwwLCJWU197SCwgRH0iXSxbMiwyLCJcXEdhbW1hX0giXSxbMiwwLCJEIl0sWzAsMSwiXFxHYW1tYSJdLFswLDIsIlxccGlfe0R9Il0sWzIsMSwiXFxpb3RhIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
%\[\begin{tikzcd}
%	{H\times D} && D \\
%	\\
%	&& {\Gamma_H}
%	\arrow["\Gamma", from=1-1, to=3-3]
%	\arrow["{\pi_{D}}", from=1-1, to=1-3]
%	\arrow["\iota"', dashed, from=1-3, to=3-3]
%\end{tikzcd}\]
%
%Note that since $\Gamma_H$ is a set of sets, $\iota$ must be defined as such: $\iota: D\rightarrow \{D\}$. Therefore a $VS_{H,D}$ is the set of $D$ such that $\iota$ is injective and the diagram commutes.
%
%\end{definition}
%
%This construction mirrors the set theoretic construction given by Lau et al. \cite{short} Union and Intersection are defined almost identically to the set theory version. 
%
%
%\begin{definition}[Category of VSAs]
%Let \textbf{VSA} be the category of version spaces. We define the category of all version spaces. 
%
%Objects in our category are of the form $VS_{H,D}$, over any $H$ and any $D$. A morphism assigns $VS_{H_1, D_1} \rightarrow VS_{H_2, D_2}$ if and only if $H_1 \subseteq H_2$.
%\end{definition}
%
%\begin{proof}
%Associativity of morphisms follows from associativity of the inclusion map. $H \subseteq H$, so there exists an identity morphism for every object. Therefore \textbf{VSA} forms a category.
%\end{proof}
%
%\begin{definition}
%The union and intersection definitions are the same as before: 
%\begin{gather*}
%    VS_{H_1, D} \bigcup VS_{H_2, D} = VS_{H_1\bigcup H_2, D}  \\ \text{ and } \\
%     VS_{H_1, D} \bigcap VS_{H_2, D} = VS_{H_1\bigcap H_2, D}  
%\end{gather*}
%\end{definition}
%
%We can use the language of graphs from Mac Lean\cite{maclean} to describe transformations. Recall that a graph $G$ is a set $O$ of objects and a set $A$ of arrows, and a pair of functions, $A\rightrightarrows B$:
%\begin{equation}
%    A \overset{\partial_0}{\underset{\partial_1}{\rightrightarrows}}, B \quad
%    \partial_0 f = \text{domain} f, \quad
%    \partial_1 f = \text{codomain} f
%\end{equation}
%
%A morphism $D:G\rightarrow G'$ of graphs is a pair of functions $D_O : O \rightarrow D'$ and $D_A: A\rightarrow A' $ such that: 
%\begin{equation}
%    D_O \partial_0 f = \partial_0 D_A f \quad \textrm{and} \quad D_O \partial_1f = \partial_1 D_A f
%\end{equation}
%for every arrow $f \in A$. Every category $C$ determines a graph $ UC $ with the same objects and arrows, forgetting the composite arrows. 
%
%Here is the definition of a version space transform from earlier: 
%\[\begin{tikzcd}
%	{A_1} & {B_1} \\
%	{A_2} & {B_2}
%	\arrow["{\tau_i}", from=1-1, to=2-1]
%	\arrow["g"', from=1-1, to=1-2]
%	\arrow["{\tau_o}", to=2-2, from=1-2]
%	\arrow["f", from=2-1, to=2-2]
%\end{tikzcd}\]
%We can transform this into a statement about graphs.
%\begin{theorem}
% If there is a bijective morphism from the graph of $VS_1$ to the graph of $VS_2$, then there exists a version space transform from $VS_1$ to $VS_2$ 
%\end{theorem}
%\begin{proof}
%Let $H_1 : A_1 \rightarrow B_1$ and $H_2 : A_2 \rightarrow B_2$ and let $VS_1$ have hypothesis space $H_1$ and $VS_2$ have hypothesis space $H_2$. Assume there exists a bijective graph morphism from the graph of $VS_1$ to the graph of $VS_2$. 
%
%Given a $VS_{H,D}$ consider the graph with objects $O=A\cup B$, and arrows the functions consistent with the examples, $A=VS_{H,D}$. Since $D = A\cup B$ define $D_O$ as such:
%\begin{equation}
%    D_O=\begin{cases} 
%      \tau_i(a) & a \in A\\
%      \tau_o(b) & b \in B 
%   \end{cases}
%\end{equation}
%We can replace our diagram of version space transforms with the language of graphs. These two definitions are equivalent, $A$ is a version space transform of $A'$ if and only if this diagram commutes for every $f\in A'$.
%% https://q.uiver.app/?q=WzAsNyxbMSwwLCJBIl0sWzAsMSwiQV8xIl0sWzIsMSwiQl8yIl0sWzMsNF0sWzAsMiwiQV8yIl0sWzIsMiwiQl8xIl0sWzEsMywiQSciXSxbMCwxLCJcXHBhcnRpYWxfMCJdLFswLDIsIlxccGFydGlhbF8yIiwyXSxbMSw0LCJEX08iXSxbMiw1LCJEX08iLDJdLFs2LDQsIlxccGFydGlhbF8wIiwyXSxbNiw1LCJcXHBhcnRpYWxfMSJdLFsxLDIsImciLDJdLFs0LDUsImYiXV0=
%\[\begin{tikzcd}
%	& A \\
%	{A_1} && {B_1} \\
%	{A_2} && {B_2} \\
%	& {A'} \\
%	&&& {}
%	\arrow["{\partial_0}", from=1-2, to=2-1]
%	\arrow["{\partial_1}"', from=1-2, to=2-3]
%	\arrow["{D_O}", from=2-1, to=3-1]
%	\arrow["{D_O}"', from=2-3, to=3-3]
%	\arrow["{\partial_0}"', from=4-2, to=3-1]
%	\arrow["{\partial_1}", from=4-2, to=3-3]
%	\arrow["g"', from=2-1, to=2-3]
%	\arrow["f", from=3-1, to=3-3]
%\end{tikzcd}\]
%The graph morphism gives us $D_A: A\rightarrow A'$ and we have the completed diagram: 
%% https://q.uiver.app/?q=WzAsNyxbMSwwLCJBIl0sWzAsMSwiQV8xIl0sWzIsMSwiQl8yIl0sWzMsNF0sWzAsMiwiQV8yIl0sWzIsMiwiQl8xIl0sWzEsMywiQSciXSxbMCwxLCJcXHBhcnRpYWxfMCJdLFswLDIsIlxccGFydGlhbF8yIiwyXSxbMSw0LCJEX08iXSxbMiw1LCJEX08iLDJdLFs2LDQsIlxccGFydGlhbF8wIiwyXSxbNiw1LCJcXHBhcnRpYWxfMSJdLFsxLDIsImciLDEseyJsYWJlbF9wb3NpdGlvbiI6MzB9XSxbNCw1LCJmIiwxLHsibGFiZWxfcG9zaXRpb24iOjMwfV0sWzAsNiwiRF9BIiwxXV0=
%\[\begin{tikzcd}
%	& A \\
%	{A_1} && {B_1} \\
%	{A_2} && {B_2} \\
%	& {A'} \\
%	&&& {}
%	\arrow["{\partial_0}", from=1-2, to=2-1]
%	\arrow["{\partial_1}"', from=1-2, to=2-3]
%	\arrow["{D_O}", from=2-1, to=3-1]
%	\arrow["{D_O}"', from=2-3, to=3-3]
%	\arrow["{\partial_0}"', from=4-2, to=3-1]
%	\arrow["{\partial_1}", from=4-2, to=3-3]
%	\arrow["g"{description, pos=0.3}, from=2-1, to=2-3]
%	\arrow["f"{description, pos=0.3}, from=3-1, to=3-3]
%	\arrow["{D_A}"{description}, <->, from=1-2, to=4-2]
%\end{tikzcd}\]
%
%Take an $f\in A'$. We can chase this $f$ around the diagram to produce show that $VS_1$ is a transform of $VS_2$. 
%\begin{gather*}
%    D_O^{-1} f D_O \partial_0 D_{A}^{-1} f = o \quad \text{for some $o \in B_1$}
%\end{gather*}
%Call $D^{-1}_A f = g$, and $i \in \partial_0 g$. Then we have 
%\begin{gather*}
%    \partial_0 D_A^{-1} f = D_O f D_O^{-1} \\
%    g(i) = D_O^{-1} f D_O \quad \forall i \in A_1 
%\end{gather*}
%With $D_O$ playing the role of $\tau$, we conclude: 
%\begin{gather*}
%    g(i) = \tau^{-1} f \tau(i) \quad \forall i \in A_1
%\end{gather*}
%and $VS_1$ is a transform of $VS_2$. 
%\end{proof}
%
%\subsection{Training}
%In machine learning applications, we train the version space by adding pairs to the example set. 

\subsection{Working example}
It would be helpful to have a working example to discuss as we update our definitions. If one were trying to generate helpful predictions for a text editor (see SMARTEdit \cite{short}), one would need a set of operations to predict. For example, one may want to predict actions such as deletes text starting with a prefix, finding the next instance of a word, moving to the third row, or inserting this text. We will use the example of a function to move between rows as our working example. 

We want the version space \textbf{Row} to represent jumping between rows in a text document. Initially our version space is going to contain all possible ways to jump between rows, but after training, it will represent only those jumps which have been completed while editing the document. 

Let $H = \{f: f: \mathbb{Z} \rightarrow \mathbb{Z}\}$. This represents all possible jumps between rows, where the domain contains the starting row and the codomain contains the ending row. Initially this starts with all possible jumps, but once an example is added, it collapses to functions which contain that jump, e.g. $f(1) = 5$, or a jump from the first row of the document to the fifth. Note that this is just one version space and a complete example would have many version spaces joined together, to allow for more than just one jump. 


\subsection{Hypothesis spaces}
We begin by defining the hypothesis space in categorical terms. By redefining the hypothesis space in categorical terms, we can define a version space transform as an arrow in a category instead of a separate set. 

In categorical terms, the category of all set maps $f: A \rightarrow B$ denoted $\operatorname{Hom}(A,B)$. In this case the hypothesis space is a subset of $\operatorname{Hom}(A,B)$. 

The first step to defining the hypothesis space is defining the $hom(\cdot, \cdot)$ functor, which is used to model the functions of a hypothesis space. The $hom$ functor is not enough alone though, as it does not preserve $A$ and $B$. To do this, we will define $H$ first then move the construction of $H$ into a comma category.

\begin{definition}
The $hom$ functor sends a pair of objects to their $Hom$ set. 

Define the $hom$ functor $hom(\cdot,\cdot)$:
\begin{gather*}
    hom(\cdot,\cdot):Set^{Op} \times Set \rightarrow Set \\
    (A,B) \rightarrow Hom(A,B) \\
\end{gather*}
\[\begin{tikzcd}
	{(A_1, B_1)} & {Hom(A_1, B_1)} \\
	{(A_2,B_2)} & {Hom(A_2,B_2)}
	\arrow[""{name=0, anchor=center, inner sep=0}, from=1-2, to=2-2]
	\arrow[""{name=1, anchor=center, inner sep=0}, from=1-1, to=2-1]
	\arrow[shorten <=10pt, shorten >=10pt, Rightarrow, from=1, to=0]
\end{tikzcd}\]
Then $H$ is a set with a monic arrow into $hom(A,B)$.
\end{definition}
This functor sends a pair of sets to their $Hom$ set, which is used to construct the hypothesis space. The functor also sends a pair of arrows in the domain to an arrow between $Hom$ sets through composition which allows maps between the sets to induce maps between hypothesis spaces. 


Notice that $hom(\cdot, \cdot)$ is a bifunctor defined in terms of of $hom(\cdot,B)$ and $hom(A,\cdot)$. Given sets $A, B$, $H$ is a monic arrow into $hom(A,B)$, the restriction to monic is necessary to preserve the domain and codomain. The problem with this definition is that it does not preserve the information of $A$ and $B$, we will fix this with a comma category. To strictly match the definition of the hypothesis space given in section 2 where $H$ is a subset of the $Hom$ set, $H$ must map into $hom(A,B)$ via the inclusion map (a monic arrow). Studying arrows other than the inclusion map is worth further work. 

The benefit of using the $hom$ functor instead of the $Hom$ set is that the $hom$ function includes a notion of arrows between objects, these arrows will induce version space transforms. 

\subsubsection{Working example}
In our working example, $H=\{f: f: \mathbb{Z} \rightarrow \mathbb{Z}\}$. We can redefine $H$ as $H \rightarrow hom(\mathbb{Z}, \mathbb{Z})$ where the arrow is the inclusion map. $H$ is an object in $Set$ of the form $Hom(\mathbb{Z},\mathbb{Z})$.

\subsubsection{Hypothesis category}
Let $(A, B) \in Set^{op} \times Set$, $H \in Set$ where $H$ is a hypothesis space, and $i:H \rightarrow hom(A,B)$ the monic inclusion functor. 

We can construct the \textbf{hypothesis category}, a comma category as such: 

% https://q.uiver.app/?q=WzAsMyxbMCwwLCJTZXQgXFx0aW1lcyBTZXRee09wfSJdLFsyLDAsIlNldCJdLFs0LDAsIlNldCJdLFswLDEsImhvbShcXGNkb3QsIFxcY2RvdCkiXSxbMiwxLCJJIiwyXV0=
\[\begin{tikzcd}
	{Set^{Op} \times Set} && Set && Set
	\arrow["{hom(\cdot, \cdot)}", from=1-1, to=1-3]
	\arrow["I"', from=1-5, to=1-3]
\end{tikzcd}\]
\begin{gather*}
    \text{With objects: } \\
    ((A,B), H, i) \\
    \text{and arrows: }  \\
	{((A_1,B_1), H_1, i)} \rightarrow  {((A_2,B_2), H_2, i)} \\
    \text{which consist of: }  \\
    u: A_2 \rightarrow A_1 \\
    v: B_1 \rightarrow B_2 \\
    s: H_1 \rightarrow H_2 \\
    \text{such that this diagram commutes: }
    % https://q.uiver.app/?q=WzAsNCxbMCwwLCJIXzEiXSxbMCwyLCJIXzIiXSxbMiwwLCJIb20oQV8xLEJfMSkiXSxbMiwyLCJIb20oQV8yLEJfMikiXSxbMCwxLCJzIl0sWzAsMiwiIiwyLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoiaG9vayIsInNpZGUiOiJ0b3AifX19XSxbMSwzXSxbMiwzLCIodSwgdileKiIsMl1d
\end{gather*}
\[\begin{tikzcd}
	{H_1} && {Hom(A_1,B_1)} \\
	\\
	{H_2} && {Hom(A_2,B_2)}
	\arrow["s", from=1-1, to=3-1]
	\arrow["i", hook, from=1-1, to=1-3]
	\arrow["i", hook, from=3-1, to=3-3]
	\arrow["{(u, v)^*}"', from=1-3, to=3-3]
\end{tikzcd}\]
%% https://q.uiver.app/?q=WzAsNixbMCwwLCIoKEFfMSxCXzEpLCBIXzEsIGkpIl0sWzAsMSwiKChBXzIsQl8yKSxIXzIsIGkpIl0sWzIsMCwiKEFfMSwgQl8xKSJdLFsyLDEsIihBXzIsQl8yKSJdLFszLDAsIkhfMSJdLFszLDEsIkhfMiJdLFswLDFdLFsyLDNdLFs0LDVdLFs2LDcsIiIsMCx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dXQ==
%\[\begin{tikzcd}
%	{((A_1,B_1), H_1, i)} && {(A_1, B_1)} & {H_1} \\
%	{((A_2,B_2),H_2, i)} && {(A_2,B_2)} & {H_2}
%	\arrow[""{name=0, anchor=center, inner sep=0}, from=1-1, to=2-1]
%	\arrow[""{name=1, anchor=center, inner sep=0}, from=1-3, to=2-3]
%	\arrow["\psi", from=1-4, to=2-4]
%	\arrow[shorten <=18pt, shorten >=18pt, Rightarrow, from=0, to=1]
%\end{tikzcd}\]
Now we can define the hypothesis space as an object in the hypothesis category, giving us $Hom(A,B)$ while preserving the information of $A$ and $B$.

\subsubsection{Working example}
We previously defined $H$, now we expand $H$ to sit inside a comma category. The comma category for the \textbf{Row} version space has objects: $((\mathbb{Z}, \mathbb{Z}), H, \iota)$ where $H$ is an object in the image of $hom(\mathbb{Z},\mathbb{Z})$ and $\iota$ is the inclusion map. 

While the notation here may be cumbersome, the essential information is the hypothesis, and the domain and codomain of them.  In this example, the essential information we care about is that $H \in Hom(\mathbb{Z}, \mathbb{Z})$, and that the domain and codomain of the $Hom$ set are preserved.  

\subsection{The examples}
Next is the examples. As we noted in the beginning of this section, we consider the examples to be a partial function $g_D: A' \rightarrow B$ where $A' \subseteq A$. Examples are used to check the consistency of a function, or whether for $f\in H$, $f(i) = o$. 

One of the difficulties in translating version space algebras to category theory is the notion of "filtering" or checking the consistency of each function in $H$. Filtering is inherently not something category theory handles well as it is designed to study ``all" objects of a class.

Using the partial function definition of examples, training can be realized as in one of two ways. Traning can be represted as expanding the example partial $g_D$ to a new partial function $g_{D'}$ where $D\subseteq D'$. This allows us to have only one example partial at a time. The other possibility is that the examples can be realized as a set $D$ of partial functions $g_{D_i}: A_i \rightarrow B $ where if $A_i \cap A_j \ne \emptyset$ then $g_i$ and $g_j$ must agree on $A_i \cap A_j$.

\subsubsection{Working example}
In our example of \textbf{Row}, examples are supposed to capture the information of jumping from one row to another. If we were to jump from the first row to the fifth, this would be the pair $(1,5)\in D$. Any function in $H$ that sends $1$ to $5$ would be consistent with this example, and remain in the version set. 

For example, the function $f(x) = x + 4$ would be an element of our version space, and correspond to the action of "move down four lines" in the text editor, a reasonable prediction. 

\subsection{Version spaces}
To define a version space, we take the functions in the hypothesis space which are consistent with our examples. We will construct the version space object as a pullback of two morphisms. 

The first morphism serves to send the hypothesis space for a partial function to the complete hypothesis space. Let $A$ be the domain and $B$ the codomain of a hypothesis space, and $A'\subseteq A$. Let $j:A' \rightarrow A$ and let $res_{A, A'} = (j, 1_B)^*$. Given a function $f \in H$:
\begin{gather*}
    res_{A,A'}(f) = f|_{A'} : A' \rightarrow B \\
    A' \xrightarrow{j} A \xrightarrow{f} B \rightarrow{1_B} B \\
    \text{ so } \\
    res_{A, A'}: Hom(A,B) \rightarrow Hom(A',B)
\end{gather*}

The other morphism we define is $g_D$ (xxx might need to rename this), defined on the one point category to ``pick" out the example partial. This morphism sends the single object in the single object category to $g_D$, the example partial. 
\begin{gather*}
    g_D : \{*\} \rightarrow Hom(A',B) \\
    * \rightarrow g_D
\end{gather*}

Finally, the pullback is: $VS_{H,D} = H\times_{Hom(A',B)} \{*\} \cong  \{f\in H : res_{A, A'}(f) = g_D\}$ 




\begin{thebibliography}{9}
\bibitem{short}
Tessa Lao, Pedro Domingos, Daniel S. Weld, Version Space Algebra and its Application to Programming by Demonstration

\bibitem{maclean}
Saunders Mac Lean, Categories for the Working Mathematician

\bibitem{original}
Tom M. Mitchell, Generalization as search
\end{thebibliography}


\end{document}