\documentclass{article}

\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{amssymb}
%\usepackage{biblatex}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]


\title{Version Space Algebras and Category Theory}
\author{Bailey Wickham}

\begin{document}
\maketitle

\begin{abstract}
We give a category theoretic definition of version space algebras and their operations. 
\end{abstract}

\section{Introduction}
Version Space Algebras are useful as a framework for machine learning in Computer Science, however their associated definitions are limited by this applied context. Many of the constructions can be generalized to be category theoretic. 
                    
Version spaces were first developed as a framework for machine learning in the 80s \cite{original}. In recent years machine learning has taken a differnt approach, yet there is still some recent work on version spaces.

Version space algebras provide a set of hypotheses and a set of examples. The example set is used to produce more relevant hypotheses based on updated information. In an applied context these are ranked by an ordering and then used to generate predictions. Due to their development in applied machine learning, the definitions are based entirely in set theory, however these constructs can be translated into a category. 

\section{Version Spaces}
Lau et al.\cite{short}  define a Version Space $VS_{H,D}$ as such: 

\begin{definition}[Version Space] 
A function $f$ is said to be consistent with an example $(a,b)$ if $f(a) = b$. 

Let the hypothesis space $H = \{f | f: A \rightarrow B \}$, where $A$ and $B$ are sets. Let the examples $D = \{(i, o) | i \in A \text{ and } o \in B\}$ Then our version space $VS_{H,D}= \{f | f(i) = o \text{ for all } (i,o) \in D\}$
\end{definition}

The hypothesis space provides an ``ambient space" to work in, or a space of functions which could possibly be models. The examples serve to constrain which functions we are studying, giving a way to refine the ambient space into a specific model.  The examples, $D$, are pairs of elements in the domain and range of these functions for which our model should respect. A version space is the set of the functions in the ambient space that are consistent with the examples. 

In practice the ambient space may be something like "words in our document", or "integers representing row and column numbers", however then only need be functions between (small) sets. Version spaces are used to define all possible actions of a specific type, then constrained to the examples observed in the current document. This is used to generate predictions, where the examples we have used in our document are used to predict future actions.

Lau et al.\cite{short} introduces the idea of Version Space Algebras (VSAs) which are version spaces generated by operations on other version spaces. A version space which is defined explicitly, or not defined in terms of operations on other version spaces, is called an \textit{atomic version space}. From a set theory perspective there is no difference between a version space algebra and a version space, there is only a difference in how they are constructed. 

There are three main operations defined on a version space. 
\begin{definition}[Version space union]
    Let $H_1 = \{f | f: A \rightarrow B\}$ and $H_1 = \{f | f: A \rightarrow B\}$ be hypothesis spaces with the same domain and range. Let $D$ be a set of examples. Then $VS_{H_1, D} \bigcup VS_{H_2, D} = VS_{H_1\bigcup H_2, D}$. 
\end{definition}

\begin{definition}[Version space intersection]
Let $H_1$ and $H_2$ be two hypothesis spaces such that the domain of functions in $H_1$ equals those of $H_2$. Let $D$ be a sequence of training examples. The version space intersection $VS_{H_1, D} \bigcap VS_{H_2, D} = VS_{H_1\bigcap H_2, D}$.
\end{definition}

\begin{definition}[Version space intersection]
Let $H_1$ and $H_2$ be two hypothesis spaces such that the domain of functions in $H_1$ equals those of $H_2$. Let $D$ be a sequence of training examples. The version space intersection $VS_{H_1, D} \bigcap VS_{H_2, D} = VS_{H_1\bigcap H_2, D}$.
\end{definition}

\begin{definition}[Version space transform]
Let $\tau_i$ be a function mapping elements from the domain of $VS_1$ to the domain of $VS_2$, and $\tau_o$ be a one-to-one mapping of elements in the range of $VS_1$ to elements in the range of $VS_2$. Version space $VS_1$ is a transform of $VS_2$ iff $VS_1 = \{g : \exists f \in VS_2, \forall i,  g(i) = \tau_o^{-1}(f(\tau_i(i)))\}$

While not provided in \cite{short}, a transform can be represented as a commutative diagram. For all $f$ this diagram commutes, where $\tau_o$ is injective and $A_i$ is the domain of $H_i$ and $B_i$ is the range of $H_i$. 

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJBXzEiXSxbMCwxLCJBXzIiXSxbMSwwLCJCXzIiXSxbMSwxLCJCXzIiXSxbMCwxLCJcXHRhdV9pIl0sWzAsMiwiZyIsMl0sWzMsMiwiXFx0YXVfbyJdLFsxLDMsImYiXV0=
\[\begin{tikzcd}
	{A_1} & {B_1} \\
	{A_2} & {B_2}
	\arrow["{\tau_i}", from=1-1, to=2-1]
	\arrow["g"', from=1-1, to=1-2]
	\arrow["{\tau_o}", to=2-2, from=1-2]
	\arrow["f", from=2-1, to=2-2]
\end{tikzcd}\]

\end{definition}

\section{Category Theory}
In the previous section we defined a version space and a set of operations on it. In this section we will redefine version spaces in categorical terms. First we define our objects which are version spaces. 

\begin{definition}[Version Space (Category)]
Let $A$ and $B$ be small sets. Then a hypothesis space $H \hookrightarrow Hom_{Set}(A, B)$. Let the examples, $D$, be a set of pairs $\{(a,b) : a \in A, b \in B\}$ $(a,b)$ that project via maps $\partial_0, \partial_1$ into $A$ and $B$ respectively.

Let $\Gamma_f$ be the graph functor: $\Gamma_f = \{(a,b) | b = f(a)\} \subseteq A\times B$. We can define a version space as the set  $VS_{H,D} = \{f : D \rightarrow \Gamma_f \text{ is injective}\}$. We say $D$ is consistent with $f$ if $D \rightarrow \Gamma_f$ is injective. A version space is all of the functions which are consistent with all of the examples: $VS_{H, D} = \{f : \text{ D is consistent with } \Gamma_f $ \}

Define the projection $\pi_D : VS_{H,D} \rightarrow D$, and $\Gamma_H = \{\Gamma_f : f \in H\}$
We can phrase this as a diagram: 
% https://q.uiver.app/?q=WzAsMyxbMCwwLCJWU197SCwgRH0iXSxbMiwyLCJcXEdhbW1hX0giXSxbMiwwLCJEIl0sWzAsMSwiXFxHYW1tYSJdLFswLDIsIlxccGlfe0R9Il0sWzIsMSwiXFxpb3RhIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
\[\begin{tikzcd}
	{H\times D} && D \\
	\\
	&& {\Gamma_H}
	\arrow["\Gamma", from=1-1, to=3-3]
	\arrow["{\pi_{D}}", from=1-1, to=1-3]
	\arrow["\iota"', dashed, from=1-3, to=3-3]
\end{tikzcd}\]

Note that since $\Gamma_H$ is a set of sets, $\iota$ must be defined as such: $\iota: D\rightarrow \{D\}$. Therefore a $VS_{H,D}$ is the set of $D$ such that $\iota$ is injective and the diagram commutes.

\end{definition}

This construction mirrors the set theoretic construction given by Lau et al. \cite{short} Union and Intersection are defined almost identically to the set theory version. 


\begin{definition}[Category of VSAs]
Let \textbf{VSA} be the category of version spaces. We define the category of all version spaces. 

Objects in our category are of the form $VS_{H,D}$, over any $H$ and any $D$. A morphism assigns $VS_{H_1, D_1} \rightarrow VS_{H_2, D_2}$ if and only if $H_1 \subseteq H_2$.
\end{definition}

\begin{proof}
Associativity of morphisms follows from associativity of the inclusion map. $H \subseteq H$, so there exists an identity morphism for every object. Therefore \textbf{VSA} forms a category.
\end{proof}

\begin{definition}
The union and intersection definitions are the same as before: 
\begin{gather*}
    VS_{H_1, D} \bigcup VS_{H_2, D} = VS_{H_1\bigcup H_2, D}  \\ \text{ and } \\
     VS_{H_1, D} \bigcap VS_{H_2, D} = VS_{H_1\bigcap H_2, D}  
\end{gather*}
\end{definition}

We can use the language of graphs from Mac Lean\cite{maclean} to describe transformations. Recall that a graph $G$ is a set $O$ of objects and a set $A$ of arrows, and a pair of functions, $A\rightrightarrows B$:
\begin{equation}
    A \overset{\partial_0}{\underset{\partial_1}{\rightrightarrows}}, B \quad
    \partial_0 f = \text{domain} f, \quad
    \partial_1 f = \text{codomain} f
\end{equation}

A morphism $D:G\rightarrow G'$ of graphs is a pair of functions $D_O : O \rightarrow D'$ and $D_A: A\rightarrow A' $ such that: 
\begin{equation}
    D_O \partial_0 f = \partial_0 D_A f \quad \textrm{and} \quad D_O \partial_1f = \partial_1 D_A f
\end{equation}
for every arrow $f \in A$. Every category $C$ determines a graph $ UC $ with the same objects and arrows, forgetting the composite arrows. 

Here is the definition of a version space transform from earlier: 
\[\begin{tikzcd}
	{A_1} & {B_1} \\
	{A_2} & {B_2}
	\arrow["{\tau_i}", from=1-1, to=2-1]
	\arrow["g"', from=1-1, to=1-2]
	\arrow["{\tau_o}", to=2-2, from=1-2]
	\arrow["f", from=2-1, to=2-2]
\end{tikzcd}\]
We can transform this into a statement about graphs.
\begin{theorem}
 If there is a bijective morphism from the graph of $VS_1$ to the graph of $VS_2$, then there exists a version space transform from $VS_1$ to $VS_2$ 
\end{theorem}
\begin{proof}
Let $H_1 : A_1 \rightarrow B_1$ and $H_2 : A_2 \rightarrow B_2$ and let $VS_1$ have hypothesis space $H_1$ and $VS_2$ have hypothesis space $H_2$. Assume there exists a bijective graph morphism from the graph of $VS_1$ to the graph of $VS_2$. 

Given a $VS_{H,D}$ consider the graph with objects $O=A\cup B$, and arrows the functions consistent with the examples, $A=VS_{H,D}$. Since $D = A\cup B$ define $D_O$ as such:
\begin{equation}
    D_O=\begin{cases} 
      \tau_i(a) & a \in A\\
      \tau_o(b) & b \in B 
   \end{cases}
\end{equation}
We can replace our diagram of version space transforms with the language of graphs. These two definitions are equivalent, $A$ is a version space transform of $A'$ if and only if this diagram commutes for every $f\in A'$.
% https://q.uiver.app/?q=WzAsNyxbMSwwLCJBIl0sWzAsMSwiQV8xIl0sWzIsMSwiQl8yIl0sWzMsNF0sWzAsMiwiQV8yIl0sWzIsMiwiQl8xIl0sWzEsMywiQSciXSxbMCwxLCJcXHBhcnRpYWxfMCJdLFswLDIsIlxccGFydGlhbF8yIiwyXSxbMSw0LCJEX08iXSxbMiw1LCJEX08iLDJdLFs2LDQsIlxccGFydGlhbF8wIiwyXSxbNiw1LCJcXHBhcnRpYWxfMSJdLFsxLDIsImciLDJdLFs0LDUsImYiXV0=
\[\begin{tikzcd}
	& A \\
	{A_1} && {B_1} \\
	{A_2} && {B_2} \\
	& {A'} \\
	&&& {}
	\arrow["{\partial_0}", from=1-2, to=2-1]
	\arrow["{\partial_1}"', from=1-2, to=2-3]
	\arrow["{D_O}", from=2-1, to=3-1]
	\arrow["{D_O}"', from=2-3, to=3-3]
	\arrow["{\partial_0}"', from=4-2, to=3-1]
	\arrow["{\partial_1}", from=4-2, to=3-3]
	\arrow["g"', from=2-1, to=2-3]
	\arrow["f", from=3-1, to=3-3]
\end{tikzcd}\]
The graph morphism gives us $D_A: A\rightarrow A'$ and we have the completed diagram: 
% https://q.uiver.app/?q=WzAsNyxbMSwwLCJBIl0sWzAsMSwiQV8xIl0sWzIsMSwiQl8yIl0sWzMsNF0sWzAsMiwiQV8yIl0sWzIsMiwiQl8xIl0sWzEsMywiQSciXSxbMCwxLCJcXHBhcnRpYWxfMCJdLFswLDIsIlxccGFydGlhbF8yIiwyXSxbMSw0LCJEX08iXSxbMiw1LCJEX08iLDJdLFs2LDQsIlxccGFydGlhbF8wIiwyXSxbNiw1LCJcXHBhcnRpYWxfMSJdLFsxLDIsImciLDEseyJsYWJlbF9wb3NpdGlvbiI6MzB9XSxbNCw1LCJmIiwxLHsibGFiZWxfcG9zaXRpb24iOjMwfV0sWzAsNiwiRF9BIiwxXV0=
\[\begin{tikzcd}
	& A \\
	{A_1} && {B_1} \\
	{A_2} && {B_2} \\
	& {A'} \\
	&&& {}
	\arrow["{\partial_0}", from=1-2, to=2-1]
	\arrow["{\partial_1}"', from=1-2, to=2-3]
	\arrow["{D_O}", from=2-1, to=3-1]
	\arrow["{D_O}"', from=2-3, to=3-3]
	\arrow["{\partial_0}"', from=4-2, to=3-1]
	\arrow["{\partial_1}", from=4-2, to=3-3]
	\arrow["g"{description, pos=0.3}, from=2-1, to=2-3]
	\arrow["f"{description, pos=0.3}, from=3-1, to=3-3]
	\arrow["{D_A}"{description}, <->, from=1-2, to=4-2]
\end{tikzcd}\]

Take an $f\in A'$. We can chase this $f$ around the diagram to produce show that $VS_1$ is a transform of $VS_2$. 
\begin{gather*}
    D_O^{-1} f D_O \partial_0 D_{A}^{-1} f = o \quad \text{for some $o \in B_1$}
\end{gather*}
Call $D^{-1}_A f = g$, and $i \in \partial_0 g$. Then we have 
\begin{gather*}
    \partial_0 D_A^{-1} f = D_O f D_O^{-1} \\
    g(i) = D_O^{-1} f D_O \quad \forall i \in A_1 
\end{gather*}
With $D_O$ playing the role of $\tau$, we conclude: 
\begin{gather*}
    g(i) = \tau^{-1} f \tau(i) \quad \forall i \in A_1
\end{gather*}
and $VS_1$ is a transform of $VS_2$. 
\end{proof}

\subsection{Training}
In machine learning applications, we train the version space by adding pairs to the example set. This gives us a contravariant pair of inclusion maps which represent training the version space. 
% https://q.uiver.app/?q=WzAsNixbMSwwLCJWU197SCxEX259Il0sWzIsMCwiVlNfe0gsRF97bisxfX0iXSxbMSwxLCJEX24iXSxbMiwxLCJEX3tuKzF9Il0sWzAsMCwiVlNfe0gsRF97bi0xfX0iXSxbMCwxLCJEX3tuLTF9Il0sWzEsMCwiXFxzdXBlIiwyXSxbMiwzLCJcXHN1YnNldGVxIl0sWzAsMl0sWzEsM10sWzAsNCwiXFxzdXBlIiwyXSxbNSwyLCJcXHN1YmUiXSxbNCw1XV0=
\[\begin{tikzcd}
	{VS_{H,D_{n-1}}} & {VS_{H,D_n}} & {VS_{H,D_{n+1}}} \\
	{D_{n-1}} & {D_n} & {D_{n+1}}
	\arrow["\supseteq"', from=1-3, to=1-2]
	\arrow["\subseteq", from=2-2, to=2-3]
	\arrow[from=2-2, to=2-2]
	\arrow[from=1-3, to=2-3]
	\arrow["\supseteq"', from=1-2, to=1-1]
	\arrow["\subseteq", from=2-1, to=2-2]
	\arrow[from=1-1, to=2-1]
\end{tikzcd}\]
with the downward arrows the projection map $pi_D$. Training a version space can be modeled as this sequence of maps

\section{New}
We need to redefine xxx major definitions in category theoretic terms: 
\begin{itemize}
    \item H, The hypothesis space
    \item D, The examples
    \item VSA, the version space
    \item Algebraic operations on VSAs
\end{itemize}
\subsection{Working example}
In this section, it would be helpful to have a working example to discuss as we update our definitions. If one were trying to generate helpful predictions for a text editor, one would need a set of operations to predict. For example, one may want to predict actions such as delete text starting with a prefix, find the next instance of a word, move to the third row, or insert this text. We will use the example of a function which is used to represent moving between rows as our working example. 

We want the version space \textbf{Row} to represent jumping between rows in a text document. Initially our version space is going to contain all possible ways to jump between rows, but after training, it will represent only those jumps which have been completed when editing the document. 

Let $H = \{f: f: \mathbb{Z} \rightarrow \mathbb{Z}\}$. This represents all possible jumps between rows, where the starting row is the domain and the ending row is the codomain. Initially this starts with all possible jumps, but once an example is added, it collapses to functions which contain that jump, i.e. $f(1) = 5$, or a jump from the first line of the document to the fifth. Note that this is just one version space and a complete example would have many version spaces joined together, this allows for more than just one jump. 


\subsection{Hypothesis spaces}
We begin by defining the hypothesis space in categorical terms. Recall the previous definition of $H$: $H\subseteq \{f: f: A \rightarrow B\}$.
By redefining the hypothesis space in categorical terms, we can define a version space transform as an arrow in a category instead of a separate set. 

The first step to defining the hypothesis space is defining the $hom(\cdot, \cdot)$ functor, which is used to model the functions of a hypothesis space. The $hom$ functor is not enough alone though, as it does not preserve $A$ and $B$. To do this, we will define $H$ first then move the construction of $H$ into a comma category.
\begin{definition}
Define the $hom$ functor $hom(\cdot,\cdot)$:
\begin{gather*}
    hom(\cdot,\cdot):Set^{Op} \times Set \rightarrow Set \\
    (A,B) \rightarrow Hom(A,B) \\
\end{gather*}
\[\begin{tikzcd}
	{(A_1, B_1)} & {Hom(A_1, B_1)} \\
	{(A_2,B_2)} & {Hom(A_2,B_2)}
	\arrow[""{name=0, anchor=center, inner sep=0}, from=1-2, to=2-2]
	\arrow[""{name=1, anchor=center, inner sep=0}, from=1-1, to=2-1]
	\arrow[shorten <=10pt, shorten >=10pt, Rightarrow, from=1, to=0]
\end{tikzcd}\]
\end{definition}
Notice that $hom(\cdot, \cdot)$ is a bifunctor defined in terms of of $hom(\cdot,B)$ and $hom(A,\cdot)$. Given sets $A, B$, $H$ is a monic arrow into $hom(A,B)$, the restriction to monic is necessary to preserve the domain and codomain. The problem with this definition is that it does not preserve the information of $A$ and $B$, we will fix this with a comma category. To strictly match the definition of the hypothesis space given in section 2, $H$ must map into $hom(A,B)$ via the inclusion map (a monic arrow). Studying arrows other than the inclusion map is worth further work. 

The benefit of using the $hom$ functor instead of the $Hom$ set is that the $hom$ function includes a notion of arrows between objects, these arrows will come to represent version space transforms.

\subsubsection{Working example}
In our working example, $H=\{f: f: \mathbb{Z} \rightarrow \mathbb{Z}\}$. We can redefine this as $I: H\rightarrow hom(\mathbb{Z},\mathbb{Z})$ under the inclusion map $I$. $H$ is an object in this category of the form $Hom(\mathbb{Z},\mathbb{Z})$.

\subsubsection{Comma Category}
To define the hypothesis space we need the $hom$ functor as well as a specific comma category. Using $I$ as the inclusion functor, we can construct a comma category as such: 

% https://q.uiver.app/?q=WzAsMyxbMCwwLCJTZXQgXFx0aW1lcyBTZXRee09wfSJdLFsyLDAsIlNldCJdLFs0LDAsIlNldCJdLFswLDEsImhvbShcXGNkb3QsIFxcY2RvdCkiXSxbMiwxLCJJIiwyXV0=
\[\begin{tikzcd}
	{Set^{Op} \times Set} && Set && Set
	\arrow["{hom(\cdot, \cdot)}", from=1-1, to=1-3]
	\arrow["I"', from=1-5, to=1-3]
\end{tikzcd}\]
\begin{gather*}
    \text{With objects: } ((A,B), H, i) \text{ where $i: I(H) \rightarrow hom(A,B)$ monic} \\
    \text{and arrows: } 
\end{gather*}
% https://q.uiver.app/?q=WzAsNixbMCwwLCIoKEFfMSxCXzEpLCBIXzEsIGkpIl0sWzAsMSwiKChBXzIsQl8yKSxIXzIsIGkpIl0sWzIsMCwiKEFfMSwgQl8xKSJdLFsyLDEsIihBXzIsQl8yKSJdLFszLDAsIkhfMSJdLFszLDEsIkhfMiJdLFswLDFdLFsyLDNdLFs0LDVdLFs2LDcsIiIsMCx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dXQ==
\[\begin{tikzcd}
	{((A_1,B_1), H_1, i)} && {(A_1, B_1)} & {H_1} \\
	{((A_2,B_2),H_2, i)} && {(A_2,B_2)} & {H_2}
	\arrow[""{name=0, anchor=center, inner sep=0}, from=1-1, to=2-1]
	\arrow[""{name=1, anchor=center, inner sep=0}, from=1-3, to=2-3]
	\arrow["\psi", from=1-4, to=2-4]
	\arrow[shorten <=18pt, shorten >=18pt, Rightarrow, from=0, to=1]
\end{tikzcd}\]
where $\psi$ is the induced arrow from one hypothesis space to another. Therefore we can define the hypothesis space as an object in the comma category defined above, giving us $Hom(A,B)$ while preserving the information of $A$ and $B$.

\subsubsection{Working example}
We previously defined $H$, now we expand $H$ to sit inside a comma category. The comma category for the \textbf{Row} version space has objects: $((\mathbb{Z}, \mathbb{Z}), H, \iota)$ where $H$ is an object in the image of $hom(\mathbb{Z},\mathbb{Z})$ and $\iota$ is the inclusion map. 

While the notation here may be cumbersome, the essential information is the hypothesis, and the domain and codomain of them.  In this example, the essential information we care about is that $H \in Hom(\mathbb{Z}, \mathbb{Z})$, and that the domain and codomain of the $Hom$ set are preserved.  

\subsection{The examples}
Next is the examples. The examples are pairs of the form $(i,o) \in D$. Examples are used to check the consistency of a function, or whether for $f\in H$, $f(i) = o$. One of the difficulties in translating version space algebras to category theory is the notion of "filtering" or checking the consistency of each function in $H$.  

We can define our examples as such: Given sets $A, B$ and a set $A'\subseteq A$, an example is a partial function $d: A' \rightarrow B$. Our examples are $D = \{d : d: A'\rightarrow B\}$. An example $d$ is consistent with a hypothesis $((A,B), H, i)$ if for all $f \in H$, $f|_{A'} = d$. A version set consists of all hypothesis consistent with the examples.

\subsubsection{Working example}
In our example of \textbf{Row}, examples are supposed to capture the information of jumping from one row to another. If we were to jump from the first row to the fifth, this would be the pair $(1,5)\in D$. Any function in $H$ that sends $1$ to $5$ would be consistent with this example, and remain in the version set. 

For example, the function $f(x) = x + 4$ would be an element of our version space, and correspond to the action of "move down four lines" in the text editor, a reasonable prediction. 

\subsection{Version spaces}
A version space is the set of hypothesis which are consistent with the current set of examples. Prof Easton, not sure how to define the VSA here? We could go with "the set of hyp. consistent with the examples, but that isn't very categorical. I'm thinking we could use the right side of the comma category we defined since it's currently the identity map (pretty much unused), but I'm not sure what that functor would look like? It would have to map into objects of the form $Hom(A,B)$... I think there is something there but I'm not sure yet. I think the set on the right would probably be $D$, the examples, so all that's left is finding a functor to map into $Set$ which assigns $D$ to $Hom(A,B)$


\begin{thebibliography}{9}
\bibitem{short}
Tessa Lao, Pedro Domingos, Daniel S. Weld, Version Space Algebra and its Application to Programming by Demonstration

\bibitem{maclean}
Saunders Mac Lean, Categories for the Working Mathematician

\bibitem{original}
Tom M. Mitchell, Generalization as search
\end{thebibliography}


\end{document}